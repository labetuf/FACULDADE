______________________________________________________________________________________________

# Atividades para Casa – Capítulo 8

## Atividade 1 – Reescrevendo código sem `goto`
Você recebeu o seguinte pseudocódigo, escrito de forma semelhante ao estilo das primeiras versões do Fortran, utilizando `goto`:

```text
i := 1
goto check

loop:
    print(i)
    i := i + 1

check:
    if (i <= 10) then
        goto loop
```

**Tarefas:**
1. Reescreva o código acima utilizando um laço de repetição pré-teste (`while`) em uma linguagem de sua escolha (C, Java, Python, etc.).

#include <stdio.h>
int main() {
    int i = 1;

    while (i <= 10) {
        printf("%d\n", i);
        i++;
    }

    return 0;
}

2. Reescreva novamente utilizando um laço de repetição controlado por contador (`for`).

#include <stdio.h>
int main() {
    for (int i = 1; i <= 10; i++) {
        printf("%d\n", i);
    }

    return 0;
}

3. Compare os três códigos (original com `goto`, versão com `while` e versão com `for`) e escreva um pequeno parágrafo discutindo qual forma é mais legível e por quê.

- O código com goto é confuso, pois exige acompanhar saltos para entender o fluxo.

- O while já deixa explícita a condição de parada (i <= 10), mas ainda exige manipular manualmente a variável i.

- O for é o mais legível e conciso, pois concentra a inicialização, condição e incremento em uma única linha.

- Conclusão: A versão com for é a mais clara e direta.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------
## Atividade 2 – Seleção múltipla em diferentes linguagens
Muitos programas oferecem menus interativos. Suponha que você precisa implementar um menu com as seguintes opções:

1. Calcular o quadrado de um número.
2. Calcular o fatorial de um número.
3. Sair do programa.

**Tarefas:**
1. Implemente esse menu em **C** utilizando `switch/case`.

#include <stdio.h>
int fatorial(int n) {
    int resultado = 1;
    for (int i = 1; i <= n; i++) {
        resultado *= i;
    }
    return resultado;
}

int main() {
    int opcao, num;

    do {
        printf("\nMenu:\n");
        printf("1. Calcular o quadrado de um número\n");
        printf("2. Calcular o fatorial de um número\n");
        printf("3. Sair\n");
        printf("Escolha uma opção: ");
        scanf("%d", &opcao);

        switch (opcao) {
            case 1:
                printf("Digite um número: ");
                scanf("%d", &num);
                printf("Quadrado: %d\n", num * num);
                break;
            case 2:
                printf("Digite um número: ");
                scanf("%d", &num);
                printf("Fatorial: %d\n", fatorial(num));
                break;
            case 3:
                printf("Saindo...\n");
                break;
            default:
                printf("Opção inválida!\n");
        }
    } while (opcao != 3);

    return 0;
}

2. Implemente o mesmo menu em **Python**, utilizando apenas `if/elif/else`.

def fatorial(n):
    resultado = 1
    for i in range(1, n + 1):
        resultado *= i
    return resultado

while True:
    print("\nMenu:")
    print("1. Calcular o quadrado de um número")
    print("2. Calcular o fatorial de um número")
    print("3. Sair")
    opcao = int(input("Escolha uma opção: "))

    if opcao == 1:
        num = int(input("Digite um número: "))
        print("Quadrado:", num * num)
    elif opcao == 2:
        num = int(input("Digite um número: "))
        print("Fatorial:", fatorial(num))
    elif opcao == 3:
        print("Saindo...")
        break
    else:
        print("Opção inválida!")

3. Execute os dois programas e compare as soluções em relação à clareza e quantidade de código.

- C (switch/case) → mais verboso, precisa declarar variáveis, escrever protótipo de função e usar scanf/printf.

- Python (if/elif/else) → mais curto e direto, não exige sintaxe extra.

4. Escreva um comentário final destacando em qual linguagem foi mais simples de implementar e justificar o motivo.

- O Python é mais simples para esse tipo de implementação, pois reduz a quantidade de código e é mais legível para menus interativos.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

## Atividade 3 – Explorando alternativas ao `goto`
Historicamente, o `goto` foi usado para resolver diferentes tipos de desvio. Hoje, a maioria das linguagens fornece alternativas como `break`, `continue` e `return`.

**Tarefas:**
1. Escreva um programa que percorra uma lista de números inteiros e:
   - Pare imediatamente a execução ao encontrar o número 0 (`break`).
   - Pule os números negativos sem processá-los (`continue`).
   - Retorne o dobro do primeiro número par encontrado (`return`).

#include <stdio.h>
int processar(int lista[], int tamanho) {
    for (int i = 0; i < tamanho; i++) {
        int numero = lista[i];

        if (numero == 0) {
            printf("Encontrado 0. Parando execução.\n");
            break;
        }

        if (numero < 0) {
            continue;
        }

        if (numero % 2 == 0) {
            return numero * 2;
        }
    }

    return -1; // Caso não encontre nenhum número par válido
}

int main() {
    int valores[] = {5, -3, 7, -1, 8, 0, 4};
    int tamanho = sizeof(valores) / sizeof(valores[0]);

    int resultado = processar(valores, tamanho);

    if (resultado != -1) {
        printf("Resultado: %d\n", resultado);
    } else {
        printf("Nenhum número par encontrado.\n");
    }

    return 0;
}

2. Comente sobre como seria a implementação desse mesmo programa utilizando apenas `goto` e rótulos, destacando as vantagens da abordagem moderna.

#include <stdio.h>
int processar_com_goto(int lista[], int tamanho) {
    int i = 0;
    if (i >= tamanho) goto fim;

    if (lista[i] == 0) {
        printf("Encontrado 0. Parando execução.\n");
        goto fim;
    }

    if (lista[i] < 0) {
        i++;
        goto inicio; // pula os negativos
    }

    if (lista[i] % 2 == 0) {
        return lista[i] * 2; // retorna o dobro do primeiro par
    }

    i++;
    goto inicio;

fim:
    return -1;
}

int main() {
    int valores[] = {5, -3, 7, -1, 8, 0, 4};
    int tamanho = sizeof(valores) / sizeof(valores[0]);

    int resultado = processar_com_goto(valores, tamanho);

    if (resultado != -1) {
        printf("Resultado: %d\n", resultado);
    } else {
        printf("Nenhum número par encontrado.\n");
    }

    return 0;
}

______________________________________________________________________________________________
______________________________________________________________________________________________

# Exercícios – Capítulo 9: Subprogramas

## Exercício 1 – Passagem de Parâmetros por Valor e por Referência
Considere o seguinte pseudocódigo de uma função que tenta dobrar o valor de um número:

```text
procedure dobrar(x)
    x := x * 2
end
```

1. Implemente esse subprograma em **C** duas vezes:
   - A primeira versão recebendo o parâmetro **por valor**.
   - A segunda versão recebendo o parâmetro **por referência** (usando ponteiros).

#include <stdio.h>

void dobrar_por_valor(int x) {
    x = x * 2;
    printf("Dentro da função (por valor): %d\n", x);
}

int main() {
    int numero = 10;
    dobrar_por_valor(numero);
    printf("Depois da chamada (por valor): %d\n", numero);
    return 0;
}

2. Escreva um programa principal que:
   - Crie uma variável inteira com valor inicial 10.
   - Chame a função `dobrar` por valor e exiba o resultado.
   - Chame a função `dobrar` por referência e exiba o resultado.

#include <stdio.h>

void dobrar_por_referencia(int *x) {
    *x = (*x) * 2;
    printf("Dentro da função (por referência): %d\n", *x);
}

int main() {
    int numero = 10;
    dobrar_por_referencia(&numero);
    printf("Depois da chamada (por referência): %d\n", numero);
    return 0;
}

**Questões:**
- Qual a diferença observada entre as duas versões?
Na versão por valor, a função recebe uma cópia da variável. Ou seja, o cálculo de x * 2 altera apenas essa cópia, e o valor da variável original 
fora da função permanece inalterado.
Na versão por referência, a função recebe o endereço de memória da variável. Assim, qualquer modificação feita dentro da função afeta diretamente 
a variável original.

- Por que o valor da variável só se altera na versão por referência?
Isso acontece porque, ao passar por referência (com ponteiros em C), a função manipula diretamente a memória da variável original. Já no caso da 
passagem por valor, a função só tem acesso a uma cópia, que deixa de existir após o término da função

- Relacione essa diferença com as estratégias de passagem de parâmetros discutidas no Capítulo 9.
Passagem por valor: preserva a variável original, útil quando não queremos que ela seja alterada. Passagem por referência: permite que a função 
modifique diretamente os dados da variável, sendo eficiente quando precisamos de alterações ou ao lidar com grandes estruturas (sem cópia desnecessária).

-----------------------------------------------------------------------------------------------------------------------------------------------------------

## Exercício 2 – Corrotinas em GoLang (primeiro contato)
As **corrotinas** permitem a execução concorrente de rotinas dentro de um programa. Em Go, isso é feito com a palavra-chave `go`.

1. Crie um arquivo chamado `main.go`.
2. Implemente o seguinte programa simples:

```go
package main

import (
    "fmt"
    "time"
)

func escrever(texto string) {
    for i := 0; i < 5; i++ {
        fmt.Println(texto, i)
        time.Sleep(time.Millisecond * 500)
    }
}

func main() {
    go escrever("Corrotina")  // executa em paralelo
    escrever("Função normal") // executa no fluxo principal
}
```

3. Compile e execute o programa com:
   ```bash
   go run main.go
   ```

**Questões:**
- O que acontece com a ordem das mensagens exibidas?
As mensagens das duas funções aparecem intercaladas, mas a ordem exata pode variar a cada execução.

- Por que as mensagens da corrotina e da função normal se intercalam?
Porque a corrotina (go escrever("Corrotina")) é executada concorrentemente em paralelo ao fluxo principal da 
função normal. O sistema operacional alterna a execução das duas rotinas, permitindo sobreposição

- Relacione esse comportamento com a definição de **corrotinas** estudada no Capítulo 9.
Corrotinas são subprogramas que podem ser executados de forma concorrente ou cooperativa, pausando e retomando 
sua execução sem encerrar completamente. Isso permite que múltiplas tarefas sejam executadas “ao mesmo tempo” 
dentro de um mesmo programa, como mostrado pelo comportamento intercalado das mensagens.
--------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------

Atividade 1 – Escopo Estático x Escopo Dinâmico 
Objetivo: Compreender a diferença entre escopo estático e dinâmico. 
Implementação em Python 
x = 10 
def f(): 
print(f"Dentro de f(), x = {x}") 
def g(): 
x = 20 
print(f"Dentro de g(), antes de chamar f(), x = {x}") 
f() 
print("Iniciando a execução...") 
g() 
Versão em JAVA: 
let x = 10; 
function f() { 
console.log(`Dentro de f(), x = ${x}`); 
} 
function g() { 
let x = 20; 
console.log(`Dentro de g(), antes de chamar f(), x = ${x}`); 
f(); 
} 
console.log("Iniciando a execução..."); 
g(); 
Atividade 2 – Tempo de Vida das Variáveis 
Objetivo: Analisar a diferença entre variáveis estáticas e automáticas. 
Implementação em C: 
#include <stdio.h> 
void contador() { 
// 'a' é uma variável automática (o padrão para variáveis locais). 
// Ela é criada e inicializada toda vez que a função é chamada. 
int a = 0;  
// 'b' é uma variável estática. 
// Ela é criada e inicializada APENAS UMA VEZ, na primeira chamada 
da função. 
// Seu valor é mantido entre as chamadas subsequentes. 
static int b = 0;  
a++; 
b++; 
printf("Valor de a (automática): %d | Valor de b (estática): %d\n", a, b); 
} 
int main() { 
printf("Primeira chamada:\n"); 
contador(); 
   
  printf("Segunda chamada:\n"); 
  contador(); 
   
  printf("Terceira chamada:\n"); 
  contador(); 
   
  return 0; 
} 
Atividade 3 – Declaração de Tipos e Coerção 
Objetivo: Explorar tipagem estática e dinâmica, além de conversão de 
tipos. 
Experimento em Java (Tipagem Estática): 
public class TesteTipos { 
    public static void main(String[] args) { 
        // 1. Variável 'num' é declarada como um inteiro (int). 
        int num = 10; 
        System.out.println("O valor inicial de num é: " + num); 
 
        // 2. Tentativa de atribuir uma string a uma variável int. 
        // A linha abaixo causará um ERRO DE COMPILAÇÃO. 
        // num = "dez"; // Erro: Incompatible types. String cannot be 
converted to int. 
 
// 3. Somando 'num + 5' (considerando que a linha com erro foi 
removida/comentada) 
int resultado = num + 5; 
System.out.println("O resultado de num + 5 é: " + resultado); 
} 
} 
Experimento em Python (Tipagem Dinâmica): 
# 1. Variável 'num' é criada e aponta para o inteiro 10. 
num = 10 
print(f"O valor inicial de num é: {num} (tipo: {type(num)})") 
# 2. A mesma variável 'num' agora aponta para a string 'dez'. 
# Isso é perfeitamente válido em Python. 
num = 'dez' 
print(f"O novo valor de num é: '{num}' (tipo: {type(num)})") 
# 3. Tentativa de somar 'num + 5' após a reatribuição. 
# Isso causará um ERRO DE EXECUÇÃO. 
print("Tentando calcular num + 5...") 
try: 
resultado = num + 5 
print(resultado) 
except TypeError as e: 
    print(f"Erro em tempo de execução: {e}") 
Atividade 4 – Trabalhando com Arrays e Registros (Structs) 
Objetivo: Compreender a diferença entre tipos homogêneos (arrays) e 
heterogêneos (structs/objetos). 
Implementação em C: 
#include <stdio.h> 
#include <string.h> // Necessário para a função strcpy 
 
int main() { 
    // --- Array: Uma coleção HOMOGÊNEA --- 
    // Todos os 5 elementos devem ser do tipo 'int'. 
    int notas[5] = {10, 8, 9, 7, 5}; 
    printf("--- Exemplo com Array ---\n"); 
    printf("A terceira nota no array é: %d\n\n", notas[2]); // Acesso por 
índice 
 
 
    // --- Struct: Um registro HETEROGÊNEO --- 
    // Agrupa dados de tipos diferentes (char[], char[], int) em uma única 
entidade. 
    struct Livro { 
        char titulo[100]; 
        char autor[100]; 
        int anoPublicacao; 
    }; 
 
    // Inicializando um objeto (uma variável do tipo 'struct Livro') 
    struct Livro meuLivro; 
    strcpy(meuLivro.titulo, "O Senhor dos Anéis"); 
    strcpy(meuLivro.autor, "J.R.R. Tolkien"); 
    meuLivro.anoPublicacao = 1954; 
     
    printf("--- Exemplo com Struct ---\n"); 
    // Acesso pelo nome do campo 
    printf("Título: %s\n", meuLivro.titulo);  
    printf("Autor: %s\n", meuLivro.autor); 
    printf("Ano: %d\n", meuLivro.anoPublicacao); 
 
    return 0; 
} 
 
Implementação em Java: 
 
Arquivo livro.java: 
// A classe define a estrutura do nosso registro heterogêneo 
public class Livro { 
    String titulo; 
    String autor; 
    int anoPublicacao; 
 
    // Construtor para facilitar a criação de objetos 
    public Livro(String titulo, String autor, int anoPublicacao) { 
        this.titulo = titulo; 
        this.autor = autor; 
        this.anoPublicacao = anoPublicacao; 
    } 
} 
Arquivo biblioteca.java: 
import java.util.ArrayList; 
 
public class Biblioteca { 
    public static void main(String[] args) { 
        // Criando uma coleção (ArrayList) para armazenar objetos do tipo 
Livro. 
        // O ArrayList em si é homogêneo: só aceita objetos 'Livro'. 
        ArrayList<Livro> estante = new ArrayList<>(); 
 
        // Criando e adicionando 3 objetos 'Livro' à coleção 
        estante.add(new Livro("Duna", "Frank Herbert", 1965)); 
        estante.add(new Livro("Fundação", "Isaac Asimov", 1951)); 
        estante.add(new Livro("Neuromancer", "William Gibson", 1984)); 
         
// Imprimindo apenas os títulos dos livros 
System.out.println("--- Títulos dos Livros na Estante ---"); 
for (Livro livro : estante) { 
System.out.println(livro.titulo); // Acesso ao campo 'titulo' de cada 
objeto 
} 
} 
} 
